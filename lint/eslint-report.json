[{"filePath":"C:\\Users\\smgal\\OneDrive\\Documents\\GitHub\\lapidoty-sqe-workshop-2018-exercise-3\\src\\js\\app.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"C:\\Users\\smgal\\OneDrive\\Documents\\GitHub\\lapidoty-sqe-workshop-2018-exercise-3\\src\\js\\code-analyzer.js","messages":[{"ruleId":"complexity","severity":2,"message":"Function has a complexity of 6.","line":55,"column":17,"nodeType":"FunctionExpression","messageId":"complex","endLine":64,"endColumn":6},{"ruleId":"complexity","severity":2,"message":"Function 'add_Colors' has a complexity of 6.","line":67,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":86,"endColumn":2},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":129,"column":1,"nodeType":"Keyword","endLine":129,"endColumn":9,"fix":{"range":[4188,4196],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":130,"column":1,"nodeType":"Keyword","endLine":130,"endColumn":9,"fix":{"range":[4264,4272],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":131,"column":1,"nodeType":"Keyword","endLine":131,"endColumn":9,"fix":{"range":[4332,4340],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":132,"column":1,"nodeType":"Keyword","endLine":132,"endColumn":9,"fix":{"range":[4398,4406],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":138,"column":1,"nodeType":"Keyword","endLine":138,"endColumn":9,"fix":{"range":[4539,4547],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":139,"column":1,"nodeType":"Keyword","endLine":139,"endColumn":9,"fix":{"range":[4599,4607],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":140,"column":1,"nodeType":"Keyword","endLine":140,"endColumn":9,"fix":{"range":[4665,4673],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":141,"column":1,"nodeType":"Keyword","endLine":141,"endColumn":9,"fix":{"range":[4727,4735],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":147,"column":1,"nodeType":"Keyword","endLine":147,"endColumn":9,"fix":{"range":[4872,4880],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":148,"column":1,"nodeType":"Keyword","endLine":148,"endColumn":9,"fix":{"range":[4948,4956],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":290,"column":1,"nodeType":"Keyword","endLine":290,"endColumn":9,"fix":{"range":[8966,8974],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":291,"column":1,"nodeType":"Keyword","endLine":291,"endColumn":9,"fix":{"range":[9025,9033],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":292,"column":1,"nodeType":"Keyword","endLine":292,"endColumn":9,"fix":{"range":[9078,9086],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":293,"column":1,"nodeType":"Keyword","endLine":293,"endColumn":9,"fix":{"range":[9157,9165],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":299,"column":1,"nodeType":"Keyword","endLine":299,"endColumn":9,"fix":{"range":[9305,9313],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":300,"column":1,"nodeType":"Keyword","endLine":300,"endColumn":9,"fix":{"range":[9376,9384],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":301,"column":1,"nodeType":"Keyword","endLine":301,"endColumn":9,"fix":{"range":[9447,9455],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":302,"column":1,"nodeType":"Keyword","endLine":302,"endColumn":9,"fix":{"range":[9516,9524],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":308,"column":1,"nodeType":"Keyword","endLine":308,"endColumn":9,"fix":{"range":[9634,9642],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":309,"column":1,"nodeType":"Keyword","endLine":309,"endColumn":9,"fix":{"range":[9705,9713],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":398,"column":1,"nodeType":"Keyword","endLine":398,"endColumn":9,"fix":{"range":[12003,12011],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":399,"column":1,"nodeType":"Keyword","endLine":399,"endColumn":9,"fix":{"range":[12056,12064],"text":"    "}},{"ruleId":"indent","severity":2,"message":"Expected indentation of 4 spaces but found 8.","line":406,"column":1,"nodeType":"Keyword","endLine":406,"endColumn":9,"fix":{"range":[12146,12154],"text":"    "}}],"errorCount":25,"warningCount":0,"fixableErrorCount":23,"fixableWarningCount":0,"source":"import * as esprima from 'esprima';\r\nimport * as escodegen from 'escodegen';\r\nimport * as local_escodegen from '../../local_escodegen';\r\n\r\nconst esgraph = require('esgraph');\r\nconst cloneDeep = require('clone-deep');\r\nvar astEval = require('static-eval');\r\n\r\nlet old_locals = new Map();\r\nlet new_locals = new Map();\r\nlet input_vector = new Map();\r\nlet current_locals = new_locals;\r\nlet isAssignment = false;\r\nlet true_path = true;\r\nlet subMode = false;\r\n\r\nconst parseCode = (codeToParse) => {\r\n    return esprima.parseScript(codeToParse);\r\n};\r\n\r\nexport function to_test(jsonObj, vector) {\r\n    input_vector = new Map(vector);\r\n    //console.log(jsonObj);\r\n    let program = Program(jsonObj);\r\n    //console.log(program);\r\n    return local_escodegen.generate(program).trim();\r\n}\r\n\r\nexport function to_testGraph(code, vector) {\r\n    input_vector = new Map(vector);\r\n    //console.log(jsonObj);\r\n    return traverse(code);\r\n}\r\n\r\n\r\nfunction programEvaluated(source) {\r\n    return {\r\n        type: 'Program',\r\n        body: Program(esprima.parse(source)).body[0].body.body,\r\n        sourceType: 'script',\r\n    };\r\n}\r\n\r\nfunction program_Not_Evaluated(source) {\r\n    return {\r\n        type: 'Program',\r\n        body: esprima.parse(source, { range: true }).body[0].body.body,\r\n        sourceType: 'script',\r\n    };\r\n}\r\n\r\nfunction add_Shapes(arr) {\r\n    let generic_shape = '\", shape=\"square';\r\n    let condition_shape = '\", shape=\"diamond';\r\n    arr.forEach(function (curr_node) {\r\n        if (curr_node.type !== 'entry') {\r\n            if (curr_node.normal !== undefined) {\r\n                curr_node.label = escodegen.generate(curr_node.astNode) + generic_shape;\r\n                curr_node = curr_node.normal;\r\n            } else if (curr_node.parent !== undefined && (curr_node.parent.type == 'IfStatement' || curr_node.parent.type == 'WhileStatement'))\r\n                curr_node.label = escodegen.generate(curr_node.astNode) + condition_shape;\r\n\r\n        }\r\n    });\r\n}\r\n\r\nfunction add_Colors(curr_node, curr_node_Evaluated) {\r\n    let green = ' \" , style=\"filled\", color=\"green'; let generic_shape = '\" , shape=\"square';\r\n    let condition_shape = '\", shape=\"diamond';\r\n    while (curr_node.next.length !== 0) {\r\n        curr_node.label = escodegen.generate(curr_node.astNode) + green;\r\n        if (curr_node.normal !== undefined) {\r\n            curr_node.label = curr_node.label + generic_shape;\r\n            curr_node = curr_node.normal; curr_node_Evaluated = curr_node_Evaluated.normal; continue;\r\n        } else {\r\n            if (curr_node.parent !== undefined && curr_node.parent.type == 'IfStatement')\r\n                curr_node.label = curr_node.label + condition_shape;\r\n            if (curr_node_Evaluated.parent.color == 'green') {\r\n                curr_node = curr_node.true; curr_node_Evaluated = curr_node_Evaluated.true;\r\n            }\r\n            else {\r\n                curr_node = curr_node.false; curr_node_Evaluated = curr_node_Evaluated.false;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction add_Numbers(arr) {\r\n    let count_node = 0;\r\n    arr.forEach(function (curr_node) {\r\n        if (curr_node.type !== 'exit' && curr_node.type !== 'entry') {\r\n            count_node++;\r\n            curr_node.label = `#${count_node}` + '\\n' + curr_node.label;\r\n        }\r\n    }\r\n    );\r\n}\r\n\r\nexport function traverse(source) {\r\n    let program_Evaluated = programEvaluated(source); let program = program_Not_Evaluated(source);\r\n    const cfg = esgraph(program); const cfg_Evaluated = esgraph(program_Evaluated);\r\n\r\n    add_Shapes(cfg[2]);\r\n    add_Colors(cfg[0].normal, cfg_Evaluated[0].normal);\r\n    add_Numbers(cfg[2]);\r\n\r\n    const dot = esgraph.dot(cfg, { source: source });\r\n    var new_dot = dot.replace(/([n](\\d+)[ ][-][>][ ][n](\\d+)[ ][[]\\w*(color=\"red\", label=\"exception\"]))/g, '');\r\n\r\n    return new_dot;\r\n}\r\n\r\nfunction Program(program) {\r\n    return {\r\n        type: 'Program',\r\n        body: filtered(StatementListItem(program.body)),\r\n        sourceType: 'script',\r\n    };\r\n}\r\n\r\n/*********** Statements ***********/\r\nfunction StatementListItem(body) {\r\n\r\n    return body.map((p) => Statement(p));\r\n}\r\n\r\nfunction Statement(statement) {\r\n    switch (statement.type) {\r\n        case 'ExpressionStatement': return ExpressionStatement(statement);\r\n        case 'ReturnStatement': return ReturnStatement(statement);\r\n        case 'BlockStatement': return BlockStatement(statement);\r\n        default: return ConditionStatement(statement);\r\n    }\r\n}\r\n\r\nfunction ConditionStatement(statement) {\r\n    switch (statement.type) {\r\n        case 'IfStatement': return IfStatement(statement);\r\n        case 'WhileStatement': return WhileStatement(statement);\r\n        case 'ForStatement': return ForStatement(statement);\r\n        default: return DeclarationStatement(statement);\r\n    }\r\n}\r\n\r\nfunction DeclarationStatement(statement) {\r\n    switch (statement.type) {\r\n        case 'VariableDeclaration': return VariableDeclaration(statement);\r\n        case 'FunctionDeclaration': return FunctionDeclaration(statement);\r\n    }\r\n}\r\n\r\nfunction FunctionDeclaration(functionDeclaration) {\r\n\r\n    return {\r\n        type: 'FunctionDeclaration',\r\n        id: Identifier(functionDeclaration.id),\r\n        params: FunctionParameter(functionDeclaration.params),\r\n        body: Statement(functionDeclaration.body),\r\n        generator: functionDeclaration.generator,\r\n        expression: functionDeclaration.expression,\r\n        async: functionDeclaration.async,\r\n    };\r\n}\r\n\r\nfunction VariableDeclaration(declaration) {\r\n\r\n    let declarations = {\r\n        type: 'VariableDeclaration',\r\n        declarations: VariableDeclarator(declaration.declarations),\r\n        kind: declaration.kind,\r\n    };\r\n    handleDeclarations(declarations);\r\n    return declarations;\r\n}\r\n\r\nfunction handleDeclarations(declarations) {\r\n    declarations.declarations.map((declaration) => handleOneDeclartion(declaration));\r\n\r\n}\r\n\r\nfunction handleOneDeclartion(declaration) {\r\n\r\n    new_locals.set(declaration.id.name, declaration.init);\r\n    old_locals = cloneDeep(new_locals);\r\n}\r\n\r\nfunction VariableDeclarator(declaration) {\r\n    return declaration.map(function make(d) {\r\n        return {\r\n            type: 'VariableDeclarator',\r\n            id: Identifier(d.id),\r\n            init: Expression(d.init),\r\n        };\r\n    });\r\n\r\n}\r\n\r\nfunction AssignmentExpression(expression) {\r\n    isAssignment = true;\r\n    let left = Expression(expression.left);\r\n    isAssignment = false;\r\n    let right = Expression(expression.right);\r\n    let ass = {\r\n        type: 'AssignmentExpression',\r\n        operator: expression.operator,\r\n        left: left,\r\n        right: right,\r\n    };\r\n    if (ass.left.type === 'MemberExpression') handle_array(ass);\r\n    else if (isLocal(ass.left.name)) handle_normal(ass);\r\n    else { input_vector.set(ass.left.name, escodegen.generate(esprima.parse(evaluate(ass.right).toString()).body[0].expression)); }\r\n    return ass;\r\n}\r\n\r\nfunction IfStatement(statement) {\r\n    let test = Expression(statement.test);\r\n    true_path = (true_path === true) ? handle_string(evaluate(test)) : true_path;\r\n    let color = (true_path === true) ? 'green' : 'red';\r\n    current_locals = cloneDeep(old_locals);\r\n    let consequent = Statement(statement.consequent); let alternate = null;\r\n    current_locals = cloneDeep(old_locals);\r\n    if (statement.alternate !== null) { true_path = !true_path; alternate = Statement(statement.alternate); }\r\n    else { true_path = true; }\r\n    old_locals = cloneDeep(new_locals);\r\n    current_locals = cloneDeep(new_locals);\r\n    let node = {\r\n        type: 'IfStatement',\r\n        test: test,\r\n        consequent: consequent,\r\n        alternate: alternate,\r\n        color: color\r\n    };\r\n    return node;\r\n}\r\n\r\nfunction BlockStatement(statement) {\r\n    return {\r\n        type: 'BlockStatement',\r\n        body: filtered(statement.body.map((s) => Statement(s))),\r\n    };\r\n}\r\n\r\nfunction WhileStatement(statement) {\r\n    let test = Expression(statement.test);\r\n\r\n    true_path = evaluate(test);\r\n    current_locals = cloneDeep(old_locals);\r\n\r\n    return {\r\n        type: 'WhileStatement',\r\n        test: test,\r\n        body: Statement(statement.body),\r\n    };\r\n}\r\n\r\nfunction ForStatement(statement) {\r\n    return {\r\n        type: 'ForStatement',\r\n        init: init(init),\r\n        test: Expression(statement.test),\r\n        update: Expression(statement.update),\r\n        body: Statement(statement.body),\r\n    };\r\n}\r\n\r\nfunction ExpressionStatement(statement) {\r\n\r\n    let s = {\r\n        type: 'ExpressionStatement',\r\n        expression: Expression(statement.expression),\r\n        directive: statement.string,\r\n    };\r\n    //  if (s.expression != null)\r\n    return s;\r\n    // else return null;\r\n}\r\n\r\nfunction ReturnStatement(statement) {\r\n    return {\r\n        type: 'ReturnStatement',\r\n        argument: Expression(statement.argument),\r\n    };\r\n}\r\n\r\n\r\n/*********** Expressions ***********/\r\n\r\nfunction Expression(expression) {\r\n    switch (expression.type) {\r\n        case 'Identifier': return Identifier(expression);\r\n        case 'Literal': return Literal(expression);\r\n        case 'AssignmentExpression': return AssignmentExpression(expression);\r\n        default: return RecurseiveExpression(expression);\r\n    }\r\n}\r\n\r\nfunction RecurseiveExpression(expression) {\r\n    switch (expression.type) {\r\n        case 'BinaryExpression': return BinaryExpression(expression);\r\n        case 'MemberExpression': return MemberExpression(expression);\r\n        case 'UnaryExpression': return UnaryExpression(expression);\r\n        default: return split(expression);\r\n    }\r\n}\r\n\r\nfunction split(expression) {\r\n    switch (expression.type) {\r\n        case 'UpdateExpression': return UpdateExpression(expression);\r\n        case 'ArrayExpression': return ArrayExpression(expression);\r\n    }\r\n}\r\n\r\nfunction Identifier(expression) {\r\n    if (subMode) return vector_substition(expression);\r\n    else {\r\n        let value = current_locals.get(expression.name);\r\n        if (value === undefined || isAssignment) {\r\n            return {\r\n                type: 'Identifier',\r\n                name: expression.name,\r\n            };\r\n        }\r\n        else { return value; }\r\n    }\r\n}\r\n\r\nfunction Literal(expression) {\r\n    return {\r\n        type: 'Literal',\r\n        value: expression.value,\r\n        raw: expression.raw,\r\n    };\r\n}\r\n\r\nfunction BinaryExpression(expression) {\r\n    return {\r\n        type: 'BinaryExpression',\r\n        operator: expression.operator,\r\n        left: Expression(expression.left),\r\n        right: Expression(expression.right),\r\n    };\r\n}\r\n\r\nfunction ArrayExpression(expression) {\r\n    return {\r\n        type: 'ArrayExpression',\r\n        elements: filtered(expression.elements.map((s) => Expression(s)))\r\n    };\r\n}\r\n\r\nfunction MemberExpression(expression) {\r\n    let node = {\r\n        type: 'MemberExpression',\r\n        computed: expression.computed,\r\n        object: Expression(expression.object),\r\n        property: Expression(expression.property),\r\n    };\r\n    let array = []; let value;\r\n    if (node.object.type !== 'ArrayExpression') {\r\n        array = current_locals.get(node.object.name);\r\n        if (array === undefined) return node;\r\n    }\r\n    else array = node.object;\r\n    let saveMode = subMode;\r\n    value = array.elements[evaluate(node.property)];\r\n    subMode = saveMode;\r\n    if (isAssignment) return node;\r\n    else return value;\r\n}\r\n\r\nfunction UnaryExpression(expression) {\r\n    return {\r\n        type: 'UnaryExpression',\r\n        operator: expression.operator,\r\n        argument: Expression(expression.argument),\r\n        prefix: expression.prefix,\r\n    };\r\n}\r\n\r\nfunction UpdateExpression(expression) {\r\n    return {\r\n        type: 'UpdateExpression',\r\n        operator: expression.operator,\r\n        argument: Expression(expression.argument),\r\n        prefix: expression.boolean\r\n    };\r\n}\r\n\r\n//*********** Utils ***********/\r\n\r\nfunction FunctionParameter(params) {\r\n\r\n    return params.map((p) => Param(p));\r\n}\r\n\r\nexport function init(init) {\r\n    switch (init.type) {\r\n        case 'Expression': return Expression(init);\r\n        default: null;\r\n    }\r\n}\r\n\r\nfunction Param(param) {\r\n\r\n    switch (param.type) {\r\n        case 'Identifier': return Identifier(param);\r\n    }\r\n}\r\n\r\nfunction filtered(array) {\r\n    return array.filter(function (el) {\r\n        return el != null;\r\n    });\r\n}\r\n\r\nfunction isLocal(name) {\r\n    return new_locals.get(name) !== undefined;\r\n}\r\n\r\nexport function handle_string(t) {\r\n\r\n    if (t == 'true') {\r\n        return true;\r\n    }\r\n    else if (t == 'false') {\r\n        return false;\r\n    }\r\n    else {\r\n        return t;\r\n    }\r\n}\r\n\r\nfunction handle_normal(ass) {\r\n    if (true_path) new_locals.set(ass.left.name, ass.right);\r\n\r\n    current_locals.set(ass.left.name, ass.right);\r\n}\r\n\r\nfunction handle_array(ass) {\r\n    let name = ass.left.object.name;\r\n    let index = evaluate(ass.left.property);\r\n    let array = current_locals.get(name);\r\n    array.elements[index] = ass.right;\r\n    new_locals.set(name, array);\r\n    current_locals.set(name, array);\r\n}\r\n\r\n//*********** Eval and Substition /***********/\r\n\r\nfunction evaluate(exp) {\r\n    subMode = true;\r\n    //console.log(exp)\r\n    let to_return = astEval(Expression(exp));\r\n    subMode = false;\r\n    //console.log(to_return)\r\n    //console.log(to_return)\r\n    return to_return;\r\n}\r\n\r\nfunction vector_substition(expression) {\r\n    let value = input_vector.get(expression.name);\r\n    return esprima.parse(value).body[0].expression;\r\n}\r\n\r\nexport { parseCode };\r\nexport { input_vector };\r\n\r\n"}]